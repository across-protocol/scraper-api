/* tslint:disable */
/* eslint-disable */
/**
 * Ampli - A strong typed wrapper for your Analytics
 *
 * This file is generated by Amplitude.
 * To update run 'ampli pull scraper'
 *
 * Required dependencies: @amplitude/analytics-node@^0.5.0
 * Tracking Plan Version: 29
 * Build: 1.0.0
 * Runtime: node.js:typescript-ampli-v2
 *
 * [View Tracking Plan](https://data.amplitude.com/risklabs/Risk%20Labs/events/main/latest)
 *
 * [Full Setup Instructions](https://data.amplitude.com/risklabs/Risk%20Labs/implementation/scraper)
 */

import * as amplitude from "@amplitude/analytics-node";

export type NodeClient = amplitude.Types.NodeClient;
export type BaseEvent = amplitude.Types.BaseEvent;
export type Event = amplitude.Types.Event;
export type EventOptions = amplitude.Types.EventOptions;
export type Result = amplitude.Types.Result;
export type NodeOptions = amplitude.Types.NodeOptions;

export type Environment = "production" | "development";

export const ApiKey: Record<Environment, string> = {
  production: "",
  development: "",
};

/**
 * Default Amplitude configuration options. Contains tracking plan information.
 */
export const DefaultConfiguration: NodeOptions = {
  plan: {
    version: "29",
    branch: "main",
    source: "scraper",
    versionId: "d15c177e-3e08-4827-bbb7-67ab60058daf",
  },
  ...{
    ingestionMetadata: {
      sourceName: "node.js-typescript-ampli",
      sourceVersion: "2.0.0",
    },
  },
};

export interface LoadOptionsBase {
  disabled?: boolean;
}

export type LoadOptionsWithEnvironment = LoadOptionsBase & {
  environment: Environment;
  client?: { configuration?: NodeOptions };
};
export type LoadOptionsWithApiKey = LoadOptionsBase & { client: { apiKey: string; configuration?: NodeOptions } };
export type LoadOptionsWithClientInstance = LoadOptionsBase & { client: { instance: NodeClient } };

export type LoadOptions = LoadOptionsWithEnvironment | LoadOptionsWithApiKey | LoadOptionsWithClientInstance;

export interface IdentifyProperties {
  /**
   * List of wallet addresses connected during Wallet Connect Transaction Completed event.
   *
   * | Rule | Value |
   * |---|---|
   * | Unique Items | true |
   * | Item Type | string |
   */
  allWalletAddressesConnected?: string[];
  /**
   * Chain ids of wallet addresses connected
   *
   * | Rule | Value |
   * |---|---|
   * | Unique Items | true |
   * | Item Type | string |
   */
  allWalletChainIds?: string[];
  initial_dclid?: any;
  initial_fbclid?: any;
  initial_gbraid?: any;
  initial_gclid?: any;
  initial_ko_click_id?: any;
  initial_msclkid?: any;
  initial_referrer?: any;
  initial_referring_domain?: any;
  initial_ttclid?: any;
  initial_twclid?: any;
  initial_utm_campaign?: any;
  initial_utm_content?: any;
  initial_utm_id?: any;
  initial_utm_medium?: any;
  initial_utm_source?: any;
  initial_utm_term?: any;
  initial_wbraid?: any;
  /**
   * Total volume of bridge transfers (since event tracking was implemented). Updated on each new transfer the user completes.
   *
   * | Rule | Value |
   * |---|---|
   * | Type | integer |
   */
  totalVolumeUsd: number;
  /**
   * Currently connected wallet address
   */
  walletAddress?: string;
  /**
   * Type of wallet connected
   */
  walletType?: string;
}

export interface TransferTransactionConfirmedProperties {
  /**
   * Capital fee percent, in decimals
   */
  capitalFeePct: string;
  /**
   * Capital fee in the bridge token, in decimals
   */
  capitalFeeTotal: string;
  /**
   * Capital fee in USD
   */
  capitalFeeTotalUsd: string;
  /**
   * From amount in the bridge token, in decimals
   */
  fromAmount: string;
  /**
   * From amount in USD
   */
  fromAmountUsd: string;
  /**
   * From chain id
   */
  fromChainId: string;
  /**
   * From chain name
   */
  fromChainName: string;
  /**
   * Token address of bridge token on from chain
   */
  fromTokenAddress: string;
  isAmountTooLow: boolean;
  /**
   * Lp fee percent, in decimals
   */
  lpFeePct: string;
  /**
   * Lp fee in the bridge token, in decimals
   */
  lpFeeTotal: string;
  /**
   * Lp fee in USD
   */
  lpFeeTotalUsd: string;
  /**
   * Gas fee in network token
   */
  NetworkFeeNative: string;
  /**
   * Network native token
   */
  NetworkFeeNativeToken: string;
  /**
   * Gas fee in USD
   */
  NetworkFeeUsd: string;
  /**
   * Recipient wallet address
   */
  recipient: string;
  /**
   * Address of referee, null if no referral used
   */
  referralProgramAddress: string;
  /**
   * Relay fee percent, in decimals
   */
  relayFeePct: string;
  /**
   * Relay fee in the gas token, in decimals
   */
  relayFeeTotal: string;
  /**
   * Relay fee in USD
   */
  relayFeeTotalUsd: string;
  /**
   * Relayer gas fee percent, in decimals
   */
  relayGasFeePct: string;
  /**
   * Relayer gas fee in the gas token, in decimals
   */
  relayGasFeeTotal: string;
  /**
   * Relayer fee in USD
   */
  relayGasFeeTotalUsd: string;
  /**
   * Route "{fromChainId}-{toChainId}"
   */
  routeChainIdFromTo: string;
  /**
   * Route "{fromChainName}-{toChainName}"
   */
  routeChainNameFromTo: string;
  /**
   * Sender wallet address
   */
  sender: string;
  /**
   * Result of user signing or rejecting wallet connection
   */
  succeeded: boolean;
  /**
   * Duration in milliseconds between TransferSigned event to the TransferTransactionCompleted event
   */
  timeFromTransferSignedToTransferCompleteInMilliseconds: string;
  /**
   * To amount of bridge token, in decimals
   */
  toAmount: string;
  /**
   * To amount in USD
   */
  toAmountUsd: string;
  /**
   * Id of the toChain
   */
  toChainId: string;
  /**
   * Name of the toChain
   */
  toChainName: string;
  /**
   * Symbol of bridge token
   */
  tokenSymbol: string;
  /**
   * Total bridge fee in the bridge token, in decimals
   */
  totalBridgeFee: string;
  /**
   * Total bridge fee percent, in decimals
   */
  totalBridgeFeePct: string;
  /**
   * Total bridge fee in USD
   */
  totalBridgeFeeUsd: string;
  /**
   * Token address of bridge token on to chain
   */
  toTokenAddress: string;
  /**
   * Resulting transaction hash of transaction, null if "result" if TransferTransactionCompleted = failed
   */
  transactionHash: string;
  /**
   * Timestamp transfer completed
   */
  transferCompleteTimestamp: string;
  transferQuoteBlockNumber: string;
}

export class Identify implements BaseEvent {
  event_type = "Identify";

  constructor(public event_properties: IdentifyProperties) {
    this.event_properties = event_properties;
  }
}

export class TransferTransactionConfirmed implements BaseEvent {
  event_type = "TransferTransactionConfirmed";

  constructor(public event_properties: TransferTransactionConfirmedProperties) {
    this.event_properties = event_properties;
  }
}

export type PromiseResult<T> = { promise: Promise<T | void> };

const getVoidPromiseResult = () => ({ promise: Promise.resolve() });

// prettier-ignore
export class Ampli {
  private disabled: boolean = false;
  private amplitude?: NodeClient;

  get client(): NodeClient {
    this.isInitializedAndEnabled();
    return this.amplitude!;
  }

  get isLoaded(): boolean {
    return this.amplitude != null;
  }

  private isInitializedAndEnabled(): boolean {
    if (!this.amplitude) {
      console.error('ERROR: Ampli is not yet initialized. Have you called ampli.load() on app start?');
      return false;
    }
    return !this.disabled;
  }

  /**
   * Initialize the Ampli SDK. Call once when your application starts.
   *
   * @param options Configuration options to initialize the Ampli SDK with.
   */
  load(options: LoadOptions): PromiseResult<void> {
    this.disabled = options.disabled ?? false;

    if (this.amplitude) {
      console.warn('WARNING: Ampli is already initialized. Ampli.load() should be called once at application startup.');
      return getVoidPromiseResult();
    }

    let apiKey: string | null = null;
    if (options.client && 'apiKey' in options.client) {
      apiKey = options.client.apiKey;
    } else if ('environment' in options) {
      apiKey = ApiKey[options.environment];
    }

    if (options.client && 'instance' in options.client) {
      this.amplitude = options.client.instance;
    } else if (apiKey) {
      this.amplitude = amplitude.createInstance();
      return this.amplitude.init(apiKey, { ...DefaultConfiguration, ...options.client?.configuration });
    } else {
      console.error("ERROR: ampli.load() requires 'environment', 'client.apiKey', or 'client.instance'");
    }

    return getVoidPromiseResult();
  }

  /**
   * Identify a user and set user properties.
   *
   * @param userId The user's id.
   * @param properties The user properties.
   * @param options Optional event options.
   */
  identify(
    userId: string | undefined,
    properties: IdentifyProperties,
    options?: EventOptions,
  ): PromiseResult<Result> {
    if (!this.isInitializedAndEnabled()) {
      return getVoidPromiseResult();
    }

    if (userId) {
      options = {...options,  user_id: userId};
    }

    const amplitudeIdentify = new amplitude.Identify();
    const eventProperties = properties;
    if (eventProperties != null) {
      for (const [key, value] of Object.entries(eventProperties)) {
        amplitudeIdentify.set(key, value);
      }
    }

    return this.amplitude!.identify(amplitudeIdentify, options);
  }

  /**
   * Track event
   *
   * @param userId The user's id.
   * @param event The event to track.
   * @param options Optional event options.
   */
  track(userId: string | undefined, event: Event, options?: EventOptions): PromiseResult<Result> {
    if (!this.isInitializedAndEnabled()) {
      return getVoidPromiseResult();
    }

    if (userId) {
      options = {...options,  user_id: userId};
    }

    return this.amplitude!.track(event, undefined, options);
  }

  flush(): PromiseResult<void> {
    if (!this.isInitializedAndEnabled()) {
      return getVoidPromiseResult();
    }

    return this.amplitude!.flush();
  }

  /**
   * TransferTransactionConfirmed
   *
   * [View in Tracking Plan](https://data.amplitude.com/risklabs/Risk%20Labs/events/main/latest/TransferTransactionConfirmed)
   *
   * On-chain transfer completed
   *
   * Owner: James Morris
   *
   * @param userId The user's ID.
   * @param properties The event's properties (e.g. capitalFeePct)
   * @param options Amplitude event options.
   */
  transferTransactionConfirmed(
    userId: string | undefined,
    properties: TransferTransactionConfirmedProperties,
    options?: EventOptions,
  ) {
    return this.track(userId, new TransferTransactionConfirmed(properties), options);
  }
}

export const ampli = new Ampli();
